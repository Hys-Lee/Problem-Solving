# 그냥 기본적인 dp를 생각해봤는데, N^2임.
# 생각해보니까, 최대 범위니까, 그 안쪽까지는 다 가능이라는 말은,
# 그냥 현재 위치로 가장 멀리서부터 도달할 수 있는 노드만 생각하면 되는거 아님?
# 근데, 제일 점프를 적게한 노드에서 도달해야 하잖아.
# 두개가 동일한가? 
# a,b,c,d에서 b,c만  d도달 가능할 때, b가 제일 점프 적게 도달 가능한가 a부터? 아닐 수도 있나?
# 절대 없음. 즉, 제일 멀리서부터 올 수 있는 노드를 알아내면 됨.

# dp로 가자.

# a[n] = a[min_i]+1임.

# <결론>적으론,
# 역으로 뒤에서부터 움직이면서,
#     어디서부터 자기한테 도달할 수 있는지 리스트를 만들어 정보를 저장할까?
#     그러고, 그 리스트에서 맨 마지막(n-1자리)부터 가장 멀리 이동해가면서 0th자리까지 이동한 횟수를 체크하면 될 듯.


# 만약에 그래프로 그려서 최단거리로 푼다면, 엣지를 만들어야 하는데, 최악경우는 N^2임.
# 아니면 그래프(엣지)를 굳이 만들지 말까?
# 근데, 어차피 엣지 전체 개수만큼은 계산할텐데, 엣지가 최악으로 N^2개 생길 수 있다는게 문제임.




# __알고리즘 40분

# ##수도코드
# backMaxRange=[n개 0으로] 초기화

# for nums를 뒤에서부터 반복하면서
#     i번째 값이 닿는 최대 뒷인덱스 위치에 backMaxRange에 i를 대입. 리스트 크기 벗어나면 n-1위치에 i대입

# pointer를 n-1로 잡고
# count=0으로 잡고
# while(pointer가 0이 될때까지)
#     backMaxRange엣어 pointer위치서부터 pointer값이 back~[pointer]위치로 이동(변경)
#         이 때, range범위 밖이면(0보다 작으면) pointer를 0으로 만들기 ->whlie조건 수정하면 필요 없을듯.
#     count+=1

# __ 수도코드 42분

# __ 틀림 50분

# __ 알고리즘 수정 후 성공 1시간 11분.
### 현재 위치까지 최대한 도달 가능한 노드 index를 저장하는 건 좋았는데,
### 이러면 최대 노드만 알게 되는거니, 듬성듬성하게 채워질 수 밖에 없는걸 망각함.
### 이 채우는 것에서도 해멨는데, 사실 최대 멀리 떨어진 곳에서 현재가지 도달가능한거니, 그 이전에 안채워진 것들은 해당 멀리 떨어진 노드가 다 도달 가능한 곳들임.
### 여기에 더불어서, 보다 앞쪽에 있는 애가 현재 노드에 도달할 수 있으면 덮어써줘야 했음.
###   애초에 이 행위를 매 node마다 반복해서 덮어쓰는것 때문에 O(N^2)였음.
###  한번에 덮어씌우려면, 최대 거리관련 저장 다 끝난다음에 덮으면 되었고, 맨 뒤에서부터 도달 가능한 가장 먼 노드들로 채우면 되었음.
###   a(n) = min(a(n+1),a(n))으로.
###   
###  여기서 얻어갈 수 있는거는, dp로 할 때, 매 index증가마다 앞이든 뒤에든 동작하며 전진해서 O(N^2)가 나온다면,
###  경계선만 찍어두고, 한바퀴 돌고(O(N)), 이후에 최종적으로 O(N)으로 한번에 처리 가능하다는 것임.


class Solution:
    def jump(self, nums: List[int]) -> int:
        backMR=[1e9 for _ in range(len(nums))] 
        # 여기가 문제. 아무 곳에서도 최대만 이동했을 때 도달하지 못하는 곳이 있기마련.
        # 이런 곳들만 차후로 뒤에값을 갖고오면 됨. 여러개가 연속으로 있을 수 있으니, 맨 뒤부터 살펴가면서 끌어다 넣기.
        # 위치 파악을 위해 -1로 두기 (초기값을 -1로 두면 해결)


        for i in range(len(nums)-1,-1,-1):
            if nums[i]+i<len(nums):
                backMR[nums[i]+i] = i
            else:
                backMR[len(nums)-1] = i

        ## test
        print('backMR',backMR)
        
        ## 잘 못 생각했네. 무조건 맨 뒤에서부터 가장 멀리 떨어진(indedx 최소)노드가 뒤에 있었따면 그걸로 밀어ㅣ버려애 했는데
        for i  in range(len(nums)-2,-1,-1):
            if backMR[i] >backMR[i+1]:
                backMR[i] = backMR[i+1]



        ## 슈바 맨 처음은 무조건 0인데
        backMR[0] = 0
        ## 최대 안쪽이라 안쓰여진 부분 채우기 -> 앞에서부터 채워야 하네...

        ## testp
        print("backMR최종: ", backMR)
        # for i in range(len(nums)-2,-1,-1): 
        #     if backMR[i]==-1:
        #         backMR[i] = backMR[i+1]
        # for i in range(1,len(nums)-1):  ## 맨 끝은ㅇ 처리 됨. 위에서
        #     if backMR[i]==-1:
        #         backMR[i] = backMR[i-1]
        ## test
        print("빈 구간(-1) 채우기: ", backMR) ## 그러네 0th값 생각하면 이 생각 했어야 했네.

        

        # ## 맨 마지막이 -1이면은 맨 마지막 직전의 값을 그대로 차용 -> 이 부분은 맨 처음에 else로 해결했어서 괜찮..
        # if backMR[len(nums)-1]==-1:
        #     backMR[len(nums)-1] = backMR[len(nums)-2]
        #     ## test
        #     print("맨 마지막 채우기: ", backMR)

        
        p=len(nums)-1
        count=0
        while(p>0):
            p = backMR[p]
            count+=1
        # test
        print(count)
        return count