# # x = int(input())

# # # 얼마나 걸릴지 체크도 어케하는지 모르겠네.

# # # 가능한 방법들 다 때려보고 그 중 가장 적게 걸리는걸 찾아야 하나?
# # # 탑다운방식으로 해야할 것 같은데..
# # # 스택이 얼마나 걸릴지 모르겠네.
# # ## 탑다운으로 하면 메모이제이션을 못써먹겠는데..
# # ## 바텀업으로 해야겠는데

# # storage = [0 for _ in range(30001)]  # 최악의 경우는 -1만 나오는 경우니까
# # print(storage[x])
# # # 1부터 시작해서 2,3등등 올라가면서 가장 빨리 만드는 방법을 생각해보자.
# # # storage는 index 1부터 사용.

# # i = 2
# # while (i <= x):
# #   choice = [30000 for _ in range(4)]
# #   if i % 5 == 0:
# #     choice[0] = storage[i // 5] + 1
# #   if i % 3 == 0:
# #     choice[1] = storage[i // 3] + 1
# #   if i % 2 == 0:
# #     choice[2] = storage[i // 2] + 1
# #   choice[3] = storage[i - 1] + 1
# #   storage[i] = min(choice)
# #   i += 1

# # print(storage[x])
# # #O(N)일듯
# # #바텀업으로해도 메모이제이션 써먹는거아님?
# # # 처음엔 5>3>2>안나눠짐 순서대로 우선순위로 부여해서 높은 우선순위가 가능하면 나머지 방법은 신경 안쓰려고 했었음.
# # # 그러나 이러면 참조하는 이전 데이터 범위가 너무 좁아지게 됨.
# # # 예를들어 26을 만들려고 할 때 그냥 13에서의 값에서 *2를 하는 행동을 해버림.
# # # 옳바른 방법은 25를 만들고 +1을 하는 것인데.
# # # 그래서 2에서부터 올라가면서 가능한한 방법을 다 사용해 볼 수 있도록 하고, 그 중에서 가장 적은 비용이 드는 방법을 고르도록 함.

# ## 책에서는 역시 min을 이용하는데, 보다 깔끔하게 이용했다.
# ## 어차피 다른 방법이 다 안통하면 그냥 직전의 수에 +1을 해야 하기 때문에, 이것을 먼저 시켜놓고 나머지들과 비교해서 최소값으로 가능한한 업데이트시키는 방법이다.

# x = int(input())
# d = [0] * 30001
# for i in range(2, x + 1):
#   d[i] = d[i - 1] + 1
#   if i % 2 == 0:
#     d[i] = min(d[i], d[i // 2] + 1)
#   if i % 3 == 0:
#     d[i] = min(d[i], d[i // 3] + 1)
#   if i % 5 == 0:
#     d[i] = min(d[i], d[i // 5] + 1)
# print(d[x])